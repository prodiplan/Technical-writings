# Development Plan: Human Verification for Grading Results

This document outlines the architecture and implementation plan for adding a human verification step to the AI grading workflow.

## 1. Overview
Currently, grading results are generated by the AI and immediately available to the user. The new workflow introduces an **Admin Verification Loop**:
1. AI generates the Grading Result.
2. Result is marked as `PENDING`.
3. Admin reviews the result.
4. Admin can **Approve**, **Reject**, or **Regenerate** the result.
5. Only `APPROVED` results are visible to the Frontend (User).

## 2. Database Schema Changes

We will modify the `grading_results` table to track the verification status. We should NOT modify `grading_sessions` for this, as the verification is specific to the *result* content.

### New Enum Type
```sql
CREATE TYPE verification_status AS ENUM ('pending', 'approved', 'rejected');
```

### Table: `grading_results`
Add the following columns:
- `verification_status`: `verification_status` (Default: `'pending'`)
- `admin_feedback`: `TEXT` (Optional, for internal notes on rejection/regeneration)
- `verified_at`: `TIMESTAMP` (Optional)
- `verified_by`: `UUID` (Optional, reference to admin user ID)

*Note: The `status` in `grading_sessions` can remain as `completed` to indicate the user has finished the test, but the `result` availability depends on `grading_results.verification_status`.*

## 3. Service Architecture Changes

### A. Session Service (Core Logic)
The `session-service` owns the `grading_results` and runs the business logic.

**1. `completeSession` Flow Update**
- When creating the record in `grading_results`:
  - Set `verification_status` = `'pending'`.
- Response to Client:
  - Return the result but include a flag (e.g., `status: 'under_review'`) or standard HTTP 202 (Accepted) indicating processing is complete but not yet available.

**2. New Internal Method: `regenerateResult(sessionId)`**
- Fetch session messages.
- Call `grading-worker` (AI) again to generate a fresh analysis.
- Update the existing `grading_results` row:
  - Update `final_score`, `readiness_level`, `analysis_report`.
  - Reset `verification_status` to `'pending'`.
  - Update `updated_at`.

**3. `getResult` Access Control**
- For **User Request** (Frontend):
  - Query `grading_results` where `session_id = ?`.
  - **Check**: If `verification_status != 'approved'`, return a specific "Processing/Pending Verification" response or generic placeholder. Do NOT show the actual data.
- For **Admin/Internal Request**:
  - Return the result regardless of status.

### B. Admin Service (Interface)
The `admin-service` provides the API for the Admin Dashboard. It will communicate with `session-service`.

**1. List Pending Verifications**
- **Endpoint**: `GET /api/v1/admin/verifications`
- **Logic**:
  - Query `grading_sessions` JOIN `grading_results`.
  - Filter `grading_results.verification_status = 'pending'`.
  - Return list of sessions with user details.

**2. Review Detail**
- **Endpoint**: `GET /api/v1/admin/verifications/:sessionId`
- **Logic**: Fetch full session details, chat history (`messages`), and the suggested `grading_result`.

**3. Verify Action**
- **Endpoint**: `POST /api/v1/admin/verifications/:sessionId/decision`
- **Body**: `{ "decision": "approve" | "reject" | "regenerate", "feedback": "..." }`
- **Logic**:
  - Forward request to `session-service`.

## 4. API Specification

### Admin Service -> Session Service Communication
The `session-service` should expose secured endpoints for these operations.

#### 1. Set Verification Status
- **URL**: `POST /internal/sessions/:sessionId/verification`
- **Body**: `{ "status": "approved" | "rejected", "feedback": "..." }`
- **Effect**: Updates `grading_results` status.

#### 2. Trigger Regeneration
- **URL**: `POST /internal/sessions/:sessionId/regenerate`
- **Body**: `{}`
- **Effect**: Triggers AI re-analysis and updates result.

### Admin Service Public API (For Admin Dashboard FE)
- `GET /verifications?status=pending`
- `GET /verifications/:sessionId`
- `POST /verifications/:sessionId/approve`
- `POST /verifications/:sessionId/reject`
- `POST /verifications/:sessionId/regenerate`

## 5. Implementation Steps

1.  **Database Migration**:
    - Create migration script to add `verification_status` enum and columns to `grading_results`.
    - Update Prisma/ORM schema in `session-service` and `result-service`.

2.  **Update Session Service**:
    - Update `completeSession` to set initial status to `pending`.
    - Implement `verifySession` logic to handle status updates.
    - Implement `regenerateSessionResult` logic to re-call Grading Worker.
    - Protect user `getResult` endpoint.

3.  **Update Admin Service**:
    - Update `GET /sessions` query to join `grading_results` and filter correctly.
    - Implement the Verify/Regenerate endpoints calling `session-service`.

4.  **Frontend Updates (Out of Scope for Backend Plan but needed)**:
    - User FE: Show "Result Under Review" state.
    - Admin FE: Dashboard for Pending items + Review Interface.

## 6. Flow Diagram (Description)

1.  **User** finishes session => `session-service` calls AI.
2.  **AI** returns Report => `session-service` saves Report (`status='pending'`).
3.  **User** requests Result => `session-service` returns "Under Review".
4.  **Admin** requests Pending List => `admin-service` returns list.
5.  **Admin** reviews specific Report.
    *   **Case A (Approve)**: Admin clicks Approve => `grading_results` updated to `approved`. User can now see the Report.
    *   **Case B (Reject)**: Admin clicks Reject => `grading_results` updated to `rejected`. (User sees "Failed" or stays "Under Review"? Policy decision needed).
    *   **Case C (Regenerate)**: Admin clicks Regenerate => `session-service` calls AI again => `grading_results` updated with NEW data and `status='pending'`. Admin reviews again.
